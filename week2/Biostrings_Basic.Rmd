---
author: "Kasper D. Hansen"
title: "Biostrings - Basic Usage"
bibliography: genbioconductor.bib
---

```{r front, child="front.Rmd", echo=FALSE}
```

## Dependencies

This document has the following dependencies:

```{r dependencies, warning=FALSE, message=FALSE}
library(Biostrings)
library(BSgenome)
library(BSgenome.Scerevisiae.UCSC.sacCer2)
```

Use the following commands to install these packages in R.

```{r biocLite, eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
biocLite(c("Biostrings", "BSgenome", "BSgenome.Scerevisiae.UCSC.sacCer2"))
```

## Overview

The `r Biocpkg("Biostrings")` package contains classes and functions for representing biological strings such as DNA, RNA and amino acids.  In addition the package has functionality for pattern matching (short read alignment) as well as a pairwise alignment function implementing Smith-Waterman local alignments and Needleman-Wunsch global alignments used in classic sequence alignment (see [@Durbin:1998] for a description of these algorithms).  There are also functions for reading and writing output such as FASTA files.

The `r Biocpkg("BSgenome")` package contains infrastructure for representing genome sequences in Bioconductor.

## Other Resources


## Representing sequences

There are two basic types of containers for representing strings.  One container represents a single string (say a chromosome or a single short read) and the other container represents a set of strings (say a set of short reads).  There are different classes intended to represent different types of sequences such as DNA or RNA sequences.

```{r DNAString, error=TRUE}
dna1 <- DNAString("ACGT-N")
dna1
DNAStringSet("ADE")
dna2 <- DNAStringSet(c("ACGT", "GTCA", "GCTA"))
dna2
```

Note that the alphabet of a `DNAString` is an extended alphabet: `-` (for insertion) and `N` are allowed.  In fact, IUPAC codes are allowed (these codes represent different characters, for example the code "M" represents either and "A" or a "C").  A list of IUPAC codes can be obtained by

```{r IUPAC}
IUPAC_CODE_MAP
```

Indexing into a `DNAString` retrieves a subsequence (similar to the standard R function `substr`), whereas indexing into a `DNAStringSet` gives you a subset of sequences.  

```{r DNAStringSubset}
dna1[2:4]
dna2[2:3]
```

Note that `[[` allows you to get a single element of a `DNAStringSet` as a `DNAString`.  This is very similar to `[` and `[[` for lists.
```{r DNAStringSubset2}
dna2[[2]] 
```

`DNAStringSet` objects can have names, like ordinary vectors
```{r DNAStringSetNames}
names(dna2) <- paste0("seq", 1:3)
dna2
```

The full set of string classes are

- `DNAString[Set]`: DNA sequences.
- `RNAString[Set]`: RNA sequences.
- `AAString[Set]`: Amino Acids sequences (protein).
- `BString[Set]`: "Big" sequences, using any kind of letter.

In addition you will often see references to `XString[Set]` in the documentation.  An `XString[Set]` is basically any of the above classes.

These classes seem very similar to standard `characters()` from base R, but there are important differences.  The differences are mostly about efficiencies when you deal with either (a) many sequences or (b) very long strings (think whole chromosomes).

## Basic functionality

Basic character functionality is supported, like

- `length`, `names`.
- `c` and `rev` (reverse the sequence).
- `width`, `nchar` (number of characters in each sequence).
- `==`, `duplicated`, `unique`.
- `as.charcater` or `toString`: converts to a base `character()` vector.
- `sort`, `order`.
- `chartr`: convert some letters into other letters.
- `subseq`, `subseq<-`, `extractAt`, `replaceAt`.
- `replaceLetterAt`.

Examples

```{r basicFunc}
width(dna2)
sort(dna2)
rev(dna2)
rev(dna1)
```

Note that `rev` on a `DNAStringSet` just reverse the order of the elements, whereas `rev` on a `DNAString` actually reverse the string.

## Biological functionality

There are also functions which are related to the biological interpretation of the sequences, including

- `reverse`: reverse the sequence.
- `complement`, `reverseComplement`: (reverse) complement the sequence.
- `translate`: translate the DNA or RNA sequence into amino acids.

```{r bioFunc}
translate(dna2)
reverseComplement(dna1)
```

## Counting letters

We very often want to count sequences in various ways.  Examples include:

- Compute the GC content of a set of sequences.
- Compute the frequencies of dinucleotides in a set of sequences.
- Compute a position weight matrix from a set of aligned sequences.

There is a rich set of functions for doing this quickly.

- `alphabetFrequency`, `letterFrequency`: Compute the frequency of all characters (`alphabetFrequency`) or only specific letters (`letterFrequency`).
- `dinucleotideFrequency`, `trinucleotideFrequency`, `oligonucleotideFrequeny`: compute frequencies of dinucleotides (2 bases), trinucleotides (3 bases) and oligonucleotides (general number of bases).
- `letterFrequencyInSlidingView`: letter frequencies, but in sliding views along the string.
- `consensusMatrix`: consensus matrix; almost a position weight matrix.

Let's look at some examples, note how the output expands to a matrix when you use the functions on a `DNAStringSet`:

```{r counting}
alphabetFrequency(dna1)
alphabetFrequency(dna2)
letterFrequency(dna2, "GC")
consensusMatrix(dna2, as.prob = TRUE)
```
(most functions allows the return of probabilities with `as.prob = TRUE`).

## Genomes

The `r Biocpkg("BSgenome")` package provides support for genomes.  In Bioconductor, we have special classes for genomes, because the chromosomes can get really big.  For example, the human genome takes up several GB of memory.

The `available.genomes()` function lists which genomes are currently available from from Bioconductor (it is possible to make your own genome package).  Note that there are several so-called "masked" genomes, where some parts of the genome are masked.  We will avoid this subject for now.

Let us load the latest yeast genome
```{r BSgenome}
available.genomes()
library("BSgenome.Scerevisiae.UCSC.sacCer2")
Scerevisiae
```

A `r Biocpkg("BSgenome")` package contains a single object which is the second component of the name.  At first, nothing is loaded into memory, which makes it very fast.  You can get the length and names of the chromosomes without actually loading them.

```{r BSgenomeLength}
seqlengths(Scerevisiae)
seqnames(Scerevisiae)
```

We load a chromosome by using the `[[` or `$` operators:
```{r BSgenomeLoad}
Scerevisiae$chrI
```

We can now do things like compute the GC content of the first chromosome
```{r gcChrI}
letterFrequency(Scerevisiae$chrI, "CG", as.prob = TRUE)
```

To iterate over chromosomes seems straightforward with `lapply`.  However, this function may end up using a lot of memory because the entire genome is loaded.  Instead there is the `bsapply` function which handles loading and unloading of different chromosomes.  The interface to `bsapply` is weird at first; you set up a `BSparams` object which contains which function you are using and which genome you are using it on (and a bit more information).  This paradigm is being used in other packages these days, for example `r Biocpkg("BiocParallel")`.  An example will make this clear:
```{r gcGenome}
param <- new("BSParams", X = Scerevisiae, FUN = letterFrequency)
head(bsapply(param, letters = "GC"))
```
note how the additional argument `letters` to the `letterFrequency` function is given as an argument to `bsapply`, not to the `BSParams` object.  This gives us a list; you can simplify the output (like the difference between `lapply` and `sapply`) by
```{r gcGenome2}
param <- new("BSParams", X = Scerevisiae, FUN = letterFrequency, simplify = TRUE)
bsapply(param, letters = "GC")
```
Note how the mitochondria chromosome is very different.  To conclude, the GC percentage of the genome is
```{r gcGenome3}
sum(bsapply(param, letters = "GC")) / sum(seqlengths(Scerevisiae))
```

## SessionInfo

\scriptsize

```{r, echo=FALSE}
sessionInfo()
```

## References

