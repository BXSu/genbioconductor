---
author: Kasper D. Hansen
title: IRanges and GenomicRanges
subtitle: An introduction
fontsize: 10pt
---

```{r front, child="front.Rmd", echo=FALSE}
```

# Dependencies

This document has the following dependecies:

```{r dependencies, warning=FALSE, message=FALSE}
library(IRanges)
library(GenomicRanges)
```

Use the following commands to install these packages in R.

```{r biocLite, eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
biocLite(c("IRanges", "GenomicRanges"))
```

# Why you should care
  
`r Biocpkg("IRanges")` and `r Biocpkg("GRanges")` are two packages I use every day to solve a variety of problems, typically related to annotating the genome.

These packages uses efficient data structures and algorithms.

Every R user who deals with genomic data should master these packages.
  
**These two packages are themselves compelling arguments for learning R!**

# Issues

We provide an overview of the two packages `r Biocpkg("IRanges")` and `r Biocpkg("GenomicRanges")`.

At first, these two packages can appear daunting, with many classes and functions.  Luckily, things are not as hard as the first appear.

Both packages now contain very extensive and useful vignettes.  Read them!


# Basic idea

A surprising amount of objects/tasks in computational biology can be formulated in terms of integer intervals, manipulation of integer intervals and overlap of integer intervals.

**Objects**: A transcript (a union of integer intervals), a collection of SNPs (intervals of width 1), TF binding sites, a collection of aligned short reads.

**Tasks**: Which transcription factor binding sites hit the promoter of genes (overlap between two sets of intervals), which SNPs hit a collection of exons, which short reads hit a predetermined set of exons.

`IRanges` are collections of integer intervals.  `GRanges` are like `IRanges`, but with an associated chromosome and strand, taking care of some book keeping.

# Basic IRanges
  
Specify IRanges by 2 of start, end, width (SEW).
  
```{r iranges1}
library(IRanges)
ir1 <- IRanges(start = c(1,3,5), end = c(3,5,7))
ir1
ir2 <- IRanges(start = c(1,3,5), width = 3)
all.equal(ir1, ir2)
``` 

An `IRange` consist of separate intervals; each interval is called a range.  So `ir1` above contains 3 ranges.


Assessor methods: `start()`, `end()`, `width()` and also replacement methods.

```{r ir_width}
start(ir1)
width(ir2) <- 1
ir2
```

They may have names
```{r ir_names}
names(ir1) <- paste("A", 1:3, sep = "")
ir1
```

and they have a single dimension
```{r ir_dim}
dim(ir1)
length(ir1)
``` 

Because of this, subsetting works like a vector
```{r ir_subset}
ir1[1]
ir1["A1"]
```

# Basic GRanges

`GRanges` are like `IRanges` but with a strand and a chromosome/contig (seqnames)

```{r}
gr <- GRanges(seqnames = "chr1", ranges = ir1,
              strand = c("+", "-", "+"))
gr
``` 

There are some additional differences; we will return to GRanges later.

# Normal IRanges

A normal IRanges is a minimal representation of the IRanges viewed as a set.  Each integer only occur in a single range and there are as few ranges as possible.  In addition, it is ordered.  Many functions produce a normal IRange.  Created by `reduce()`.

```{r, echo=FALSE}
ir <- IRanges(start = c(1,3,7,9), end = c(4,4,8,10))
``` 

```{r, echo=FALSE, fig.height=2, small.mar=TRUE}
plotRanges(ir)
``` 

```{r, echo=FALSE, fig.height=1.75, small.mar=TRUE}
plotRanges(reduce(ir))
``` 

```{r}
ir
reduce(ir)
``` 

Answers: "Given a set of overlapping exons, which bases belong to an exon?"


# Disjoin

From some perspective, `disjoin()` is the opposite of `reduce()`.  An example explains better:

```{r, eval=FALSE}
disjoin(ir1)
```

```{r, echo=FALSE, fig.height=2, small.mar=TRUE}
plotRanges(ir)
``` 

```{r, echo=FALSE, fig.height=1.75, small.mar=TRUE}
plotRanges(disjoin(ir))
``` 

Answers: "Give a set of overlapping exons, which bases belong to the same set of exons?"

# Manipulating IRanges, intra-range

"Intra-range" manipulations are manipulations where each original range gets mapped to a new range.

Examples of these are: `shift()`, `narrow()`, `flank()`, `resize()`, `restrict()`.

For example, `resize()` can be extremely useful.  It has a `fix` argument controling where the resizing occurs from.

```{r ir_resize}
resize(ir, width = 1, fix = "start")
resize(ir, width = 1, fix = "end")
```

The help page is `?"intra-range-methods"` (note that there is both a help page in `r Biocpkg("IRanges")` and `r Biocpkg("GenomicRanges")`).

# Manipulating IRanges, as sets

Manipulating `IRanges` as sets means that we view each `IRange` as a set of integers; individual integers is either contained in one or more ranges or they are not.  This is equivalent to calling `reduce()` on the `IRange` first.

Once this is done, we can use standard: `union()`, `intersect()`, `setdiff()`, `gaps()` between two `IRanges` (which all returns normalized `IRanges`).

```{r ir_sets}
ir1 <- IRanges(start = c(1, 3, 5), width = 1)
ir2 <- IRanges(start = c(4, 5, 6), width = 1)
union(ir1, ir2)
intersect(ir1, ir2)
```

There is also an element-wise version of these: `punion()`, `pintersect()`, `psetdiff()`, `pgap()`; this is similar to say `pmax` from base R.   In my experience, these functions are seldom used.



# Finding Overlaps

Finding (pairwise) overlaps between two `IRanges` is done by `findOverlaps()`.  This function is very important and amazingly fast!

```{r findOverlaps}
ir1 <- IRanges(start = c(1,4,8), end = c(3,7,10))
ir2 <- IRanges(start = c(3,4), width = 3)
ov <- findOverlaps(ir1, ir2)
ov
``` 

It returns a `Hits` object which describes the relationship between the two `IRanges`.  This object is basically a two-column matrix of indicies into the two `IRanges`.

The two columns of the hits object can be accessed by `queryHits()` and `subjectHits()` (often used with `unique()`).

For example, the first row of the matrix describes that the first range of `ir1` overlaps with the first range of `ir2`. Or said differently, they have a non-empty intersection:

```{r findOverlaps_ill}
intersect(ir1[subjectHits(ov)[1]],
          ir2[queryHits(ov)[2]])
```

The elements of `unique(subjectHits)` gives you the indices of the range which actually had an overlap.

```{r subjectHits}
subjectHits(ov)
unique(subjectHits(ov))
```

The list of arguments to `findOverlaps()` is long and takes a while to master.  For example, you can ask to only get an overlap if two ranges overlap by a certain number of bases.

```{r, tidy=TRUE}
args(findOverlaps)
``` 

# countOverlaps

For efficiency, there is also `countOverlaps()`, which just returns the number of overlaps.  This function is faster and takes up less memory because it does not have to keep track of which ranges overlap, just the number of overlaps.

```{r countOverlaps}
countOverlaps(ir1, ir2)
``` 

# Finding nearest IRanges

Sometimes you have two sets of `IRanges` and you need to know which ones are closest to each other.  Functions for this include `nearest()`, `precede()`, `follow()`.  Watch out for ties!

```{r}
ir1
ir2
nearest(ir1, ir2)
``` 

# Return to GRanges

`GRanges` are like `IRanges` with strand and chromosome.  Strand can be `+`, `-` and `*`. The value `*` indicates 'unknown strand' or 'unstranded'.  This value usually gets treated as a third strand.

```{r}
gr
``` 

Natural accessor functions: `strand()`, `seqnmes()`, `ranges()`, `start()`, `end()`, `width()`.

Because the have strand, we now have operations which are relative to the direction of transcription (`upstream()`, `downstream()`):

```{r}
flank(gr, 2, start = FALSE)
``` 

# GRanges, seqinfo


`GRanges` operate within a universe of sequences (chromosomes/contigs) and their lengths.

This is described through `seqinfo`:

```{r seqinfo}
seqinfo(gr)
seqlengths(gr) <- c("chr1" = 10)
seqinfo(gr)
seqlevels(gr)
seqlengths(gr)
``` 

Especially the length of the chromosomes are used by some functions.  For example `gaps()` return the stretches of the genome not covered by the `GRanges`.

```{r gaps}
gaps(gr)
```

In this example, we know that the last gap stops at 10, because that is the length of the chromosome.  Note how a range on the `*` strand appears in the result.

Let us expand the `GRanges` with another chromosome

```{r gr2}
gr2 <- GRanges(seqnames = c("chr1", "chr2", "chr1"), strand = "*", ranges = ir1)
gr2
sort(gr2)
seqlevels(gr2)
seqlevels(gr2) <- c("chr2", "chr1")
sort(gr2)
```

Note how the order of `seqlevels` affects how the `GRanges` is sorted.

An easy way to drop chromosomes is by
```{r seqlevelsForce}
seqlevels(gr2, force = TRUE) <- "chr1"
gr2
```
There is also `dropSeqlevels()`, `keepSeqlevels()`, `keepStandardChromosomes`.

Finally, you can put a `genome()` on the differenct sequences, like
```{r genome}
genome(gr) <- "hg18"
genome(gr2) <- "hg19"
```

This becomes valuable when you deal with data from different genome versions (as we all do), because it allows R to throw an error, like

```{r gr-error, error=TRUE}
findOverlaps(gr, gr2)
```

The fact that each sequence may have its own genome is more esoteric. One usecase is for experiments where the experimenter have spiked in sequences exogenous to the original organism.

# GRanges, genomeInfoDb

Some things gets tiring, like

- Adding `seqlengths` to your `GRanges`
- Dealing with the fact that different annotation resources uses different naming conventions for chromosomes (like `chrM` vs `chrMT`).

This is one reason the `GenomeInfoDb` package was created.

FIXME

# GRanges, metadata

`GRanges` (unlike `IRanges`) may have associated metadata.  This is immensely useful.  The formal way to access and set this metadata is through `values` or `elementMetadata` or `mcols`, like


```{r}
values(gr) <- DataFrame(score = c(0.1, 0.5, 0.3))
gr
``` 

(note the `DataFrame` ... we'll get back to this).


A much easier way to set and access metadata is through the `$` operator

```{r grdollar}
gr$score
gr$score2 = gr$score * 0.2
gr
```

# DataFrame

The `r Biocpkg("S4Vectors")` package introduced the `DataFrame` class.  This class is very similar to the base `data.frame` class from R, but it allows columns of any class, provided a number of required methods are supported.  For example, `DataFrame` can have `IRanges` as columns, unlike `data.frame`:

```{r DataFrame}
df1 <- DataFrame(iranges = ir1)
df1
df1$iranges
df2 <- data.frame(iranges = ir1)
df2
```

In the `data.frame` case, the `IRanges` gives rise to 4 columns, whereas it is a single column when a `DataFrame` is used.



# Biology usecase I

Suppose we want to identify TF binding sites that overlaps known SNPs.

snps: a `GRanges` (of width 1)  
TF: a `GRanges`

```{r, eval=FALSE}
findOverlaps(snps, TF)
``` 

(watch out for strand)

# Biology usecase II

Suppose we have a set of DMRs (think genomic regions) and a set of
CpG Islands and we want to find all DMRs within 10kb of a CpG Island.

dmrs: a `GRanges`  
islands: a `GRanges`

```{r, eval=FALSE} 
findOverlaps(dmrs, resize(islands, 
      width = 20000 + width(islands), fix = "center"))
``` 

(watch out for strand)

# Biology usecase III

Suppose we want to compute the average coverage of bases belonging to
(known) exons.

reads: a `GRanges`.  
exons: a `GRanges`.

```{r, eval=FALSE}
bases <- reduce(exons)
nBases <- sum(width(bases))
nCoverage <- sum(Views(coverage(reads), bases))
nCoverage / nBases
``` 

(watch out for strand)

# SessionInfo

\scriptsize

```{r, echo=FALSE}
sessionInfo()
```
